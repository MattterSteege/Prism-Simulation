const referenceWavelength=500;function getSellmeierValue(wavelength){const L2=(wavelength*=1e-9)*wavelength;return Math.sqrt(1+1.03961212*L2/(L2-600069867e-23)+.231792344*L2/(L2-200179144e-22)+1.01046945*L2/(L2-1.03560653e-10))}function getAirIndex(wavelength){return 1+.05792105/(238.0185-Math.pow(1e6*wavelength,-2))+.00167917/(57.362-Math.pow(1e6*wavelength,-2))}function getIndexOfRefraction(wavelength,refractiveIndex){const nAirReference=this.getAirIndex(500);let x=(refractiveIndex-1)/(1+refractiveIndex*(this.getSellmeierValue(500)-nAirReference));return x=Math.max(Math.min(x,1),0),x*this.getSellmeierValue(wavelength)+(1-x)*this.getAirIndex(wavelength)}const _user={showDebug:!1,showNormals:!1,showIntersections:!1,AmountOfRays:100,doStagedDraw:0,maxLightBounces:25},handler={get:(target,key)=>"object"==typeof target[key]&&null!==target[key]?new Proxy(target[key],handler):target[key],set(target,prop,value){target[prop]=value,s.valid=!1,target.showDebug}};let user=new Proxy(_user,handler);function nmToRGB(wavelength){var factor,red,green,blue;return wavelength>=380&&wavelength<440?(red=-(wavelength-440)/60,green=0,blue=1):wavelength>=440&&wavelength<490?(red=0,green=(wavelength-440)/50,blue=1):wavelength>=490&&wavelength<510?(red=0,green=1,blue=-(wavelength-510)/20):wavelength>=510&&wavelength<580?(red=(wavelength-510)/70,green=1,blue=0):wavelength>=580&&wavelength<645?(red=1,green=-(wavelength-645)/65,blue=0):wavelength>=645&&wavelength<781?(red=1,green=0,blue=0):(red=0,green=0,blue=0),factor=wavelength>=380&&wavelength<420?.3+.7*(wavelength-380)/40:wavelength>=420&&wavelength<701?1:wavelength>=701&&wavelength<781?.3+.7*(780-wavelength)/80:0,0!==red&&(red=Math.round(255*Math.pow(red*factor,.8))),0!==green&&(green=Math.round(255*Math.pow(green*factor,.8))),0!==blue&&(blue=Math.round(255*Math.pow(blue*factor,.8))),[red,green,blue]}function RGBToHex(rgb){for(var hex="#",i=0;i<3;i++){var h=rgb[i].toString(16);h.length<2&&(h="0"+h),hex+=h}return hex}function rotatePointsAroundCenter(points,angle){var angleRadians=angle*Math.PI/180,centerX=0,centerY=0;points.forEach((function(point){centerX+=point.x,centerY+=point.y})),centerX/=points.length,centerY/=points.length;var newPoints=[];return points.forEach((function(point){var x=centerX+(point.x-centerX)*Math.cos(angleRadians)-(point.y-centerY)*Math.sin(angleRadians),y=centerY+(point.x-centerX)*Math.sin(angleRadians)+(point.y-centerY)*Math.cos(angleRadians);newPoints.push({x:x,y:y})})),newPoints}function rotatePoints(points,angleInDegrees){const angleInRadians=DegreesToRadians(angleInDegrees),centerX=points.reduce(((sum,point)=>sum+point.x),0)/points.length,centerY=points.reduce(((sum,point)=>sum+point.y),0)/points.length;return points.map((point=>({x:centerX+(point.x-centerX)*Math.cos(angleInRadians)-(point.y-centerY)*Math.sin(angleInRadians),y:centerY+(point.x-centerX)*Math.sin(angleInRadians)+(point.y-centerY)*Math.cos(angleInRadians)})))}function rotatePointsXY(points,angleInRadians,x,y){const centerX=x,centerY=y;return points.map((point=>({x:centerX+(point.x-centerX)*Math.cos(angleInRadians)-(point.y-centerY)*Math.sin(angleInRadians),y:centerY+(point.x-centerX)*Math.sin(angleInRadians)+(point.y-centerY)*Math.cos(angleInRadians)})))}function DegreesToRadians(degrees){return degrees*Math.PI/180}function RadiansToDegrees(radians){return 180*radians/Math.PI}function dotProduct(a,b){return a.x*b.x+a.y*b.y}const delay=ms=>new Promise((res=>setTimeout(res,ms)));function normalizeDegreeAngle(angle){for(;angle<=0;)angle+=360;for(;angle>=360;)angle-=360;return angle}function calculateTotalCalulations(){var shapes=s.shapes.length,rays=s.rays.length;return shapes*user.maxLightBounces*rays}function getClosestNumber(number,array){for(var closest=array[0],closestDiff=Math.abs(number-closest),i=1;i<array.length;i++){var diff=Math.abs(number-array[i]);diff<closestDiff&&(closest=array[i],closestDiff=diff)}return closest}function getPcSpeed(){var start=(new Date).getTime();let x=0;for(var i=0;i<1e3;i++)for(var j=0;j<1e3;j++)x+=Math.pow(i,j);var time=(new Date).getTime()-start;return 100-Math.min(100,time/100)}function Shape(){}function Text(x,y,font,fill,content){this.x=x||0,this.y=y||0,this.font=font,this.fill=fill,this.w=10*content.length,this.content=content,this.points=[{x:this.x,y:this.y+18},{x:this.x+this.w,y:this.y+18},{x:this.x+this.w,y:this.y+20+18},{x:this.x,y:this.y+20+18}]}function Rectangle(x,y,w,h,angle,fill){this.x=x||0,this.y=y||0,this.w=w||1,this.h=h||1,this.angleDegrees=normalizeDegreeAngle(angle||0),this.fill=fill||"#AAAAAA",this.updatePoints()}Shape.prototype.intersectRay=function(ray,shape){const angleRadians=Math.atan2(ray.to.y-ray.from.y,ray.to.x-ray.from.x),x1=ray.from.x+.1*Math.cos(angleRadians),y1=ray.from.y+.1*Math.sin(angleRadians),x2=ray.to.x,y2=ray.to.y,points=shape.points,n=points.length;let intersections=[];if(n>2){let _x1,_y1,_x2,_y2,_x3,_y3,_x4,_y4;for(let i=0;i<n;i++){_x1=points[i].x,_y1=points[i].y,_x2=points[(i+1)%n].x,_y2=points[(i+1)%n].y,_x3=x1,_y3=y1,_x4=x2,_y4=y2;const intersection=VectorIntersectsVector(_x1,_y1,_x2,_y2,_x3,_y3,_x4,_y4);intersection&&intersections.push(intersection)}}if(2===n){let _x1,_y1,_x2,_y2,_x3,_y3,_x4,_y4;_x1=points[0].x,_y1=points[0].y,_x2=points[1].x,_y2=points[1].y,_x3=x1,_y3=y1,_x4=x2,_y4=y2;const intersection=VectorIntersectsVector(_x1,_y1,_x2,_y2,_x3,_y3,_x4,_y4);intersection&&intersections.push(intersection)}if(0===intersections.length)return;let closestIntersection=null,closestDistance=1e4;intersections.forEach((intersection=>{const distance=Math.sqrt(Math.pow(intersection.x-x1,2)+Math.pow(intersection.y-y1,2));distance<closestDistance&&(closestIntersection=intersection,closestDistance=distance)}));const angleOfRay=normalizeDegreeAngle(RadiansToDegrees(Math.atan2(y1-closestIntersection.y,x1-closestIntersection.x))),normal1=normalizeDegreeAngle(closestIntersection.normals[0]),normal2=normalizeDegreeAngle(closestIntersection.normals[1]);return getClosestNumber(angleOfRay,[normal1,normal2])===normal1?closestIntersection.normals=normal1:closestIntersection.normals=normal2,{from:{x:x1,y:y1},to:{x:closestIntersection.x,y:closestIntersection.y},shape:shape,normal:closestIntersection.normals};function VectorIntersectsVector(x1,y1,x2,y2,x3,y3,x4,y4){const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);if(0===den)return;const t=((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/den,u=-((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3))/den,angleDegrees1=RadiansToDegrees(Math.atan2(y2-y1,x2-x1))+90,angleDegrees2=RadiansToDegrees(Math.atan2(y2-y1,x2-x1))-90;return t>=0&&t<=1&&u>=0&&u<=1?{x:x1+t*(x2-x1),y:y1+t*(y2-y1),normals:[angleDegrees1,angleDegrees2]}:void 0}},Shape.prototype.contains=function(mx,my){const points=this.points;let isInside=!1;const n=points.length;for(let i=0,j=n-1;i<n;j=i++){const xi=points[i].x,yi=points[i].y,xj=points[j].x,yj=points[j].y;yi>my!=yj>my&&mx<(xj-xi)*(my-yi)/(yj-yi)+xi&&(isInside=!isInside)}return isInside},Shape.prototype.stroke=function(ctx,strokeStyle,lineWidth){ctx.strokeStyle=strokeStyle,ctx.lineWidth=lineWidth,this.draw(ctx),ctx.stroke()},Text.prototype=new Shape,Text.prototype.constructor=Text,Text.prototype.draw=function(ctx){ctx.font=this.font,ctx.fillStyle=this.fill;var metrics=ctx.measureText(this.content);this.w=metrics.width,this.h=20,ctx.fillText(this.content,this.x,this.y)},Text.prototype.contains=function(mx,my){return this.x<=mx&&this.x+this.w>=mx&&this.y>=my&&this.y+this.h>=my},Text.prototype.updatePoints=function(){this.points=[{x:this.x,y:this.y-18},{x:this.x+this.w,y:this.y-18},{x:this.x+this.w,y:this.y+this.h-18},{x:this.x,y:this.y+this.h-18}]},Rectangle.prototype=new Shape,Rectangle.prototype.constructor=Rectangle,Rectangle.prototype.draw=function(ctx){ctx.fillStyle=this.fill,ctx.strokeStyle=this.fill,ctx.beginPath(),ctx.moveTo(this.points[0].x,this.points[0].y),this.points.forEach((function(point){ctx.lineTo(point.x,point.y)})),ctx.lineTo(this.points[0].x,this.points[0].y),ctx.closePath(),ctx.stroke()},Rectangle.prototype.contains=function(mx,my){return this.x<=mx&&this.x+this.w>=mx&&this.y<=my&&this.y+this.h>=my},Rectangle.prototype.updatePoints=function(){this.points=[{x:this.x,y:this.y},{x:this.x+this.w,y:this.y},{x:this.x+this.w,y:this.y+this.h},{x:this.x,y:this.y+this.h}],this.points=rotatePoints(this.points,this.angleDegrees)};const CircleResolutions=1e3;function Circle(x,y,w,fill){this.x=x||0,this.y=y||0,this.w=w||1,this.fill=fill||"#AAAAAA",this.updatePoints()}function Triangle(x,y,width,angle,fill){this.x=x||0,this.y=y||0,this.width=width||1,this.angleDegrees=normalizeDegreeAngle(angle||0),this.fill=fill||"#AAAAAA",this.updatePoints()}function Line(x1,y1,length,w,angle,fill){this.x=x1||0,this.y=y1||0,this.length=length||1,this.w=w||1,this.angleDegrees=normalizeDegreeAngle(angle||0),this.fill=fill||"#AAAAAA",this.updatePoints()}function Ray(x,y,angle,waveLength,fill,lightColorInternal){this.x=x||0,this.y=y||0,this.w=50,this.h=20,this.angleDegrees=normalizeDegreeAngle(angle||0),this.waveLength=waveLength||500,this.fill=fill||"#AAAAAA",this.lightColorInternal=lightColorInternal||null,this.updatePoints(),this.isInsideObject=!1}Circle.prototype=new Shape,Circle.prototype.constructor=Circle,Circle.prototype.draw=function(ctx){ctx.fillStyle=this.fill,ctx.strokeStyle=this.fill,ctx.beginPath(),ctx.moveTo(this.points[0].x,this.points[0].y),this.points.forEach((function(point){ctx.lineTo(point.x,point.y)})),ctx.lineTo(this.points[0].x,this.points[0].y),ctx.closePath(),ctx.stroke()},Circle.prototype.contains=function(mx,my){return Math.pow(mx-this.x,2)+Math.pow(my-this.y,2)<=Math.pow(this.w,2)},Circle.prototype.updatePoints=function(){this.points=[];for(var i=0;i<1e3;i++){var angle=i/1e3*Math.PI*2;this.points.push({x:this.x+this.w*Math.cos(angle),y:this.y+this.w*Math.sin(angle)})}},Triangle.prototype=new Shape,Triangle.prototype.constructor=Triangle,Triangle.prototype.draw=function(ctx){ctx.fillStyle=this.fill,ctx.strokeStyle=this.fill,ctx.beginPath(),ctx.moveTo(this.points[0].x,this.points[0].y),this.points.forEach((function(point){ctx.lineTo(point.x,point.y)})),ctx.lineTo(this.points[0].x,this.points[0].y),ctx.closePath(),ctx.stroke()},Triangle.prototype.updatePoints=function(){const height=Math.sqrt(3)/2*this.width;this.points=[{x:this.x,y:this.y+height},{x:this.x+this.width,y:this.y+height},{x:this.x+this.width/2,y:this.y}],this.points=rotatePoints(this.points,this.angleDegrees)},Line.prototype=new Shape,Line.prototype.constructor=Line,Line.prototype.draw=function(ctx){ctx.fillStyle=this.fill,ctx.strokeStyle=this.fill,ctx.beginPath(),ctx.moveTo(this.points[0].x,this.points[0].y),this.points.forEach((function(point){ctx.lineTo(point.x,point.y)})),ctx.lineTo(this.points[0].x,this.points[0].y),ctx.closePath(),ctx.stroke()},Line.prototype.updatePoints=function(){this.points=[{x:this.x,y:this.y},{x:this.x+this.w,y:this.y},{x:this.x+this.w,y:this.y+this.length},{x:this.x,y:this.y+this.length}],this.points=rotatePoints(this.points,this.angleDegrees)},Ray.prototype=new Shape,Ray.prototype.constructor=Ray;let check=0;function CanvasState(canvas){this.canvas=canvas,this.width=canvas.width,this.height=canvas.height,this.ctx=canvas.getContext("2d"),document.defaultView&&document.defaultView.getComputedStyle&&(this.stylePaddingLeft=parseInt(document.defaultView.getComputedStyle(canvas,null).paddingLeft,10)||0,this.stylePaddingTop=parseInt(document.defaultView.getComputedStyle(canvas,null).paddingTop,10)||0,this.styleBorderLeft=parseInt(document.defaultView.getComputedStyle(canvas,null).borderLeftWidth,10)||0,this.styleBorderTop=parseInt(document.defaultView.getComputedStyle(canvas,null).borderTopWidth,10)||0);var html=document.body.parentNode;this.htmlTop=html.offsetTop,this.htmlLeft=html.offsetLeft,this.valid=!1,this.shapes=[],this.rays=[],this.dragging=!1,this.dragoffx=0,this.dragoffy=0;var myState=this;canvas.addEventListener("mousedown",(function(e){for(var mouse=myState.getMouse(e),mx=mouse.x,my=mouse.y,shapes=myState.shapes,i=shapes.length-1;i>=0;i--)if(shapes[i].contains(mx,my)){var mySel=shapes[i];return myState.dragoffx=mx-mySel.x,myState.dragoffy=my-mySel.y,myState.dragging=!0,myState.selection=mySel,void(myState.valid=!1)}var rays=myState.rays;if(rays[0].contains(mx,my))return myState.dragoffx=mx-rays[0].x,myState.dragoffy=my-rays[0].y,myState.dragging=!0,myState.selection=rays[0],void(myState.valid=!1);myState.selection&&(myState.selection=null,myState.valid=!1)}),!0),canvas.addEventListener("mousemove",(function(e){if(myState.dragging&&"Ray"!==myState.selection.constructor.name){var mouse=myState.getMouse(e);myState.selection.x=mouse.x-myState.dragoffx,myState.selection.y=mouse.y-myState.dragoffy,myState.selection.updatePoints(),myState.valid=!1}else if(myState.dragging&&"Ray"===myState.selection.constructor.name){myState.rays.forEach((ray=>{var mouse=myState.getMouse(e);ray.x=mouse.x-myState.dragoffx,ray.y=mouse.y-myState.dragoffy,ray.updatePoints(),myState.valid=!1}))}}),!0),canvas.addEventListener("mouseup",(function(){myState.dragging=!1}),!0),canvas.addEventListener("wheel",(function(e){for(var mouse=myState.getMouse(e),mx=mouse.x,my=mouse.y,shapes=myState.shapes,rays=myState.rays,i=shapes.length-1;i>=0;i--)if(shapes[i].contains(mx,my)){var mySel=shapes[i];mySel.angleDegrees+=e.deltaY/100,mySel.updatePoints(),myState.valid=!1}rays[0].contains(mx,my)&&rays.forEach((ray=>{ray.angleDegrees+=e.deltaY/100,myState.valid=!1}))}),!0),canvas.addEventListener("touchstart",(function(e){e.preventDefault();var touch=e.touches[0],mouseEvent=new MouseEvent("mousedown",{clientX:touch.clientX,clientY:touch.clientY});canvas.dispatchEvent(mouseEvent)}),!1);let lastTouches=[];canvas.addEventListener("touchmove",(function(e){if(e.preventDefault(),1===e.touches.length){var touch=e.touches[0],mouseEvent=new MouseEvent("mousemove",{clientX:touch.clientX,clientY:touch.clientY});canvas.dispatchEvent(mouseEvent)}else if(2===e.touches.length){let touches=[];for(let i=0;i<e.touches.length;i++)touches.push({x:e.touches[i].clientX,y:e.touches[i].clientY});if(2===lastTouches.length){let angle=Math.atan2(touches[0].y-touches[1].y,touches[0].x-touches[1].x)-Math.atan2(lastTouches[0].y-lastTouches[1].y,lastTouches[0].x-lastTouches[1].x);myState.rays.forEach((ray=>{ray.angleDegrees+=angle,myState.valid=!1}))}lastTouches=touches}}),!1),canvas.addEventListener("touchend",(function(e){e.preventDefault();var mouseEvent=new MouseEvent("mouseup",{});canvas.dispatchEvent(mouseEvent)}),!1),this.interval=10,setInterval((function(){myState.draw()}),myState.interval)}Ray.prototype.draw=async function(ctx){this.updatePoints();let rayParts=this.calculateRay(s.shapes);check=Math.random(),ctx.fillStyle=this.fill,ctx.strokeStyle=this.fill,ctx.beginPath(),ctx.moveTo(this.points[0].x,this.points[0].y),this.points.forEach((function(point){ctx.lineTo(point.x,point.y)})),ctx.lineTo(this.points[0].x,this.points[0].y),ctx.closePath(),ctx.fill(),s.shapes.forEach((shape=>{shape.contains(this.emittingPoint.x,this.emittingPoint.y)&&(this.isInsideObject=!0)}));const CurrentCheck=check;for(const rayPart of rayParts){rayParts.indexOf(rayPart);if(CurrentCheck===check&&(ctx.beginPath(),ctx.strokeStyle=this.lightColorInternal||RGBToHex(nmToRGB(this.waveLength)),ctx.moveTo(rayPart.from.x,rayPart.from.y),ctx.lineTo(rayPart.to.x,rayPart.to.y),ctx.stroke(),ctx.closePath(),user.showNormals&&rayPart.normal)){const length=50,x2=rayPart.to.x+length*Math.cos(rayPart.normal*Math.PI/180),y2=rayPart.to.y+length*Math.sin(rayPart.normal*Math.PI/180);ctx.beginPath(),ctx.strokeStyle="white",ctx.moveTo(rayPart.to.x,rayPart.to.y),ctx.lineTo(x2,y2),ctx.stroke(),ctx.closePath()}}},Ray.prototype.calculateRay=function(shapes){let rayParts=[];const angleRadians=DegreesToRadians(this.angleDegrees);rayParts.push({from:this.emittingPoint,to:{x:this.emittingPoint.x+1e4*Math.cos(angleRadians),y:this.emittingPoint.y+1e4*Math.sin(angleRadians)}});let isInsideObject=this.isInsideObject;for(let i=0;i<user.maxLightBounces;i++){let closestIntersection=null,closestShape=null,closestDistance=1e4,closestNormals=null,intersections=[];const lastRayPart=rayParts[rayParts.length-1];if(shapes.forEach((shape=>{const intersection=shape.intersectRay(lastRayPart,shape);intersection&&intersections.push(intersection)})),0===intersections.length)break;if(intersections.forEach((intersection=>{var skip=!1;if(shapes.forEach((shape=>{shape!==intersection.shape&&shape.contains(intersection.to.x,intersection.to.y)&&(skip=!0)})),skip)return;const distance=Math.sqrt(Math.pow(intersection.to.x-intersection.from.x,2)+Math.pow(intersection.to.y-intersection.from.y,2));distance<closestDistance&&(closestIntersection=intersection,closestDistance=distance,closestShape=intersection.shape,closestNormals=intersection.normal)})),!closestIntersection){rayParts[rayParts.length-1]={from:this.emittingPoint,to:{x:this.emittingPoint.x+1e4*Math.cos(angleRadians),y:this.emittingPoint.y+1e4*Math.sin(angleRadians)}};break}rayParts[rayParts.length-1]=closestIntersection,isInsideObject=!1,shapes.forEach((shape=>{const x_center=(closestIntersection.from.x-closestIntersection.to.x)/2,y_center=(closestIntersection.from.y-closestIntersection.to.y)/2,x=closestIntersection.to.x+x_center,y=closestIntersection.to.y+y_center;shape.contains(x,y)&&(isInsideObject=!0)}));const angle_normal=closestNormals,angle_ray=normalizeDegreeAngle(RadiansToDegrees(Math.atan2(closestIntersection.from.y-closestIntersection.to.y,closestIntersection.from.x-closestIntersection.to.x))),diff=angle_normal-angle_ray,nextRefractionAngle=this.calculateRefractedAngle(isInsideObject?getSellmeierValue(this.waveLength):getAirIndex(this.waveLength),isInsideObject?getAirIndex(this.waveLength):getSellmeierValue(this.waveLength),diff);if(rayParts[rayParts.length-1].refraction={nextRefractionAngle:nextRefractionAngle,diff:diff,angle_ray:angle_ray,angle_normal:angle_normal},nextRefractionAngle.totalInteralReflection){let newAngle=normalizeDegreeAngle(angle_normal+diff),newRay={from:closestIntersection.to,to:{x:closestIntersection.to.x+1e4*Math.cos(newAngle*Math.PI/180),y:closestIntersection.to.y+1e4*Math.sin(newAngle*Math.PI/180)}};rayParts.push(newRay)}else{let newAngle=normalizeDegreeAngle(angle_normal+180+-1*nextRefractionAngle.angleToAdd),newRay={from:closestIntersection.to,to:{x:closestIntersection.to.x+1e4*Math.cos(newAngle*Math.PI/180),y:closestIntersection.to.y+1e4*Math.sin(newAngle*Math.PI/180)}};rayParts.push(newRay)}isInsideObject=!isInsideObject}return 0===rayParts.length&&rayParts.push({from:this.emittingPoint,to:{x:this.emittingPoint.x+1e4*Math.cos(angleRadians),y:this.emittingPoint.y+1e4*Math.sin(angleRadians)}}),this.RayParts=rayParts,rayParts},Ray.prototype.updatePoints=function(){this.points=[{x:this.x,y:this.y},{x:this.x+this.w,y:this.y},{x:this.x+this.w,y:this.y+this.h},{x:this.x,y:this.y+this.h}];const rot=this.points=rotatePoints(this.points,this.angleDegrees);this.emittingPoint={x:(rot[1].x+rot[2].x)/2,y:(rot[1].y+rot[2].y)/2}},Ray.prototype.calculateRefractedAngle=function(n1,n2,angleIncidence){Math.abs(n2-n1);const isNegative=angleIncidence<0;angleIncidence=Math.abs(angleIncidence);const radiansIncidence=(angleIncidence=Math.min(angleIncidence,90))*Math.PI/180;if(n2<n1){if(angleIncidence>this.calculateCriticalAngle(n1,n2))return{totalInteralReflection:!0}}const angleRefraction=180*Math.asin(n1*Math.sin(radiansIncidence)/n2)/Math.PI;return{totalInteralReflection:!1,angleToAdd:isNegative?-angleRefraction:angleRefraction}},Ray.prototype.calculateCriticalAngle=function(n1,n2){return n1<=n2?(console.error("Material A (n1) must have a higher refractive index than material B (n2), but if we switch the values this would be the ouput:"),180*Math.asin(n1/n2)/Math.PI):180*Math.asin(n2/n1)/Math.PI},CanvasState.prototype.addShape=function(shape){this.shapes.push(shape),this.valid=!1},CanvasState.prototype.addRay=function(ray){this.rays.push(ray),this.valid=!1},CanvasState.prototype.clear=function(){this.ctx.clearRect(0,0,this.width,this.height)},CanvasState.prototype.draw=function(){if(!this.valid){var ctx=this.ctx,shapes=this.shapes;this.clear();for(var l=shapes.length,i=0;i<l;i++){var shape=shapes[i];shape.x>this.width||shape.y>this.height||shape.x+shape.w<0||shape.y+shape.h<0||shapes[i].draw(ctx)}var rays=this.rays;for(l=rays.length,i=0;i<l;i++){var ray=rays[i];ray.draw(ctx),ray.calculateRay(shapes)}this.valid=!0}},CanvasState.prototype.getMouse=function(e){var element=this.canvas,offsetX=0,offsetY=0;if(void 0!==element.offsetParent)do{offsetX+=element.offsetLeft,offsetY+=element.offsetTop}while(element=element.offsetParent);return offsetX+=this.stylePaddingLeft+this.styleBorderLeft+this.htmlLeft,offsetY+=this.stylePaddingTop+this.styleBorderTop+this.htmlTop,{x:e.pageX-offsetX,y:e.pageY-offsetY}};var s=new CanvasState(document.getElementById("canvas"));function init(){s.canvas.width=s.width=window.innerWidth-.15*window.innerWidth,s.canvas.height=s.height=window.innerHeight,s.addShape(new Triangle(300,200,700,0,"#ffbe0b")),s.addShape(new Rectangle(200,200,100,100,0,"#fb5607")),s.addShape(new Line(400,200,100,5,0,"#ff006e")),s.addShape(new Circle(600,200,50,"#8338ec"));let multiplier=300/user.AmountOfRays;for(let i=0;i<user.AmountOfRays;i++)s.addRay(new Ray(200,500,-10,700-multiplier*i,"#888"))}function reset(){s.shapes=[],s.rays=[],s.valid=!1,init()}
//# sourceMappingURL=PWS.min.js.map